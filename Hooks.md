<h1>React Hook</h1>
<p>리액트에는 함수형 컴포넌트의 상태를 관리하고 생명주기 기능을 사용하게 해주는 React Hook 라는 특별한 함수가 존재한다.</p>
<p>훅은 몇가지 규칙을 가지고 있는데</p>
<p>반복문이나 조건문 내부에서 Hook 를 호출하면 안된다</p>
<p>리액트 훅은 호출되는 순서에 의존하기 때문에 조건문이나 반복문 안에서 실행하게 될 경우 해당 부분을 건너뛰는 일이 발생할 수도 있기 때문에 순서가 꼬여 버그가 발생할 수 있다. </p>
<p>이 규칙을 준수하면 useStaet , useEffect 가 여러번 호출되는 경우에도 Hook 의 상태를 올바르게 유지할 수 있다.</p>
<p>Hook은 리액트 함수 내에서만 호출해야 한다. 일반적인 js 함수에서는 호출하면 안된다</p>
<p>함수형 컴포넌트나 custom Hook 에서는 호출 가능하다.</p>
<h2>useState</h2>
<p>useState는 상태를 관리하는 리액트 Hook 으로 기본적으로 구조분해 할당을 해서 사용한다</p>
const [example , setExample] = useState()
<p>()안에는 초기 값을 설정할 수 있으며 다양한 값을 넣을 수 있다.</p>
<h2>useEffect</h2>
<p>useEffect 는 함수형 컴포넌트에서 사이드 이펙트를 수행할 수 있도록 도와준다.</p>
<p>사이트 이펙트는 데이터 불러오기 , 구독 설정 , Dom 조작 등이 있다.</p>
<p>useEffect는 아래와 같은 방식으로 사용하는데 의존성 배열이라는 값을 가진다.</p>
useEffect(()=>{
console.log()
},[])
<p>의존성 배열의 값이 변할때 마다 useEffect 내부의 함수가 실행된다.</p>
<p>기본값으로 아무것도 넣지 않았을 때에는 컴포넌트의 마운트 , 언마운트 시기에 동작한다.</p>
<h2>useRef</h2>
<p>useRef 는 특정 돔 요소에 직접적으로 참조할 때에 사용된다.</p>
<p>사용방법은 아래와 같으며 useState와 동일하게 초기값이 설정이 가능하다.</p>
const example = useRef()
<!--<input ref={example}>-->
<p>useRef의 경우 값이 변경되어도 컴포넌트가 다시 렌더링되지 않는다는 특징이 있다.</p>
<h2>useMemo , useCallback</h2>
<p>위 두 hook 의 경우에는 모두 메모이제이션과 관련이 있다.</p>
<p>메모이제이션이란 특정한 함수나 결과 값을 기억해서 동일한 입력값이 들어올 경우에 기억해놓은 연산을 다시 사용하겠다는 것이다.</p>
<p>useCallback이나 useMemo를 사용할 경우 중복된 연산을 피할 수 있어 애플리케이션 최적화에 유용하다.</p>
<p>useCallback,useMemo 의 경우  useEffect와 사용방법은 동일하다.</p>
<p>이 둘의 차이점으로는 반환값에 있다 useMemo의 경우 값을 반환하고 useCallback의 경우 함수를 반환한다.</p>
<br/>
<h2>나의 한줄 생각</h2>
<p>작성을 하다보니 자주 사용하지 않는 useMemo에 대해서 잘 모르고 있다는 생각이 들었다. 활용할 수 있는 예제를 만들어서 사용해봐야겠다.</p>
